// Copyright 02-Aug-2022 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

package data;

import haxe.Exception as Exc;
import data.Prop;
import data.Reason;
import dm.Opt;
import dm.Rs;
import dm.Tp;
import dm.It;
import I18n._;
import I18n._args;

class Step {
  /// 'true' if can be used in demonstration.
  public final isActive: Bool;
  /// Proposition generated by 'reason'.
  public final prop: PropT;
  /// Reason of 'prop'
  public final reason: ReasonT;

  /// Sets 'true' the field 'isActive'
  function new (isActive: Bool, prop: PropT, reason: ReasonT) {
    this.isActive = isActive;
    this.prop = prop;
    this.reason = reason;
  }

  ///Returns a new Step with the field 'isActive' set to 'false'.
  /// After call this function the step can not be reactivated.
  function deactivate (): Step {
    return new Step(false, prop, reason);
  }

  static function mk (prop: PropT, reason: ReasonT): Step {
    return new Step(true, prop, reason);
  }

  /// Adds a new step to 'steps' and returns a new array.
  /// If there is some error, returns Tp(error, null). Otherwise returns
  /// Tp("", newSteps)
  ///   steps: Array to modify.
  ///   reason: New step reason.
  ///   book: Demonstration book for solving Theorem reasons.
  public static function add (
    steps: Array<Step>, reason: ReasonT, book: Book
  ): Result<Array<Step>> {
    function fail0 (err: String): Result<Array<Step>> {
      return Error(err);
    }

    function fail (
      template: String, vars: Array<String>
    ): Result<Array<Step>> {
      return Error(_args(template, vars));
    }

    // The index returned is 0-based
    function getLastSup (): Result<Tp<Int, PropT>> {
      var ix = -1;
      return It.from(steps).reduce(
        Error(_("There is no supposition active")),
        (r, step) -> {
          ++ix;
          return switch (step.reason) {
            case Sup(p): step.isActive ? Ok(new Tp(ix, p)) : r;
            default: r;
          }
        }
      );
    }

    function getLastStep (): Result<PropT> {
      if (steps.length == 0)
        return Error(_("There is no previous step"));
      return Ok(steps[steps.length - 1].prop);
    }

    final newSteps = switch (reason) {
      case Sup(p): It.from(steps).push(Step.mk(p, reason));
      case Theorem(id, index, replacements): {
        switch (book.get(id)) {
          case None: return fail(_("Theorem '%0' not found"), [id]);
          case Some(d):
            final th = Prop.replace(d.conclusion, replacements);
            final prev = steps[index].prop;
            switch (prev) {
              case C(p, q) if (Prop.eq(p, th)):
                It.from(steps).push(Step.mk(q, reason));
              default: switch (th) {
                case C(p, q) if (Prop.eq(p, prev)):
                  It.from(steps).push(Step.mk(q, reason));
                default: return fail(
                  _("Teorem %0\nis not applicable to\n%1"),
                  [Prop.toString(th), Prop.toString(prev)]
                );
              }
            }
        }
      }
      case IN: {
        switch (getLastSup()) {
          case Error(e): return fail0(e);
          case Ok(tp): switch (steps[steps.length - 1].prop) {
            case N(p):
              if (It.from(steps).indexf(s -> Prop.eq(s.prop, p)) == -1) {
                return fail(_("'%0'\nnot found"), [Prop.toString(p)]);
              }
              It.from(steps).take(tp.e1)
                .cat(It.from(steps).drop(tp.e1)
                  .map(s -> new Step(false, s.prop, s.reason))
                ).push(Step.mk(Prop.mkN(tp.e2), reason))
              ;
            case p: return fail(
              _("'0'\nis not a negation"), [Prop.toString(p)]);
          }
        }
      }
      case EN: {
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case N(p1): switch (p1) {
              case N(p2): It.from(steps).push(Step.mk(p2, reason));
              default: return fail(
                  _("%0\nis not a double negation"),
                  [Prop.toString(s)]
                );
            }
            default: return fail(
                _("%0\nis not a double negation"),
                [Prop.toString(s)]
              );
          }
        }
      }
      case IC: {
        switch (getLastSup()) {
          case Error(e): return fail0(e);
          case Ok(tp):
            It.from(steps).take(tp.e1)
              .cat(It.from(steps).drop(tp.e1)
                .map(s -> new Step(false, s.prop, s.reason))
              ).push(Step.mk(
                Prop.mkC(tp.e2, steps[steps.length - 1].prop), reason
              ))
            ;
        }
      }
      case EC: {
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case C(p, q): {
              if (
                It.from(steps).indexf(s -> Prop.eq(s.prop, p) && s.isActive) == -1
              ) {
                return fail(_("'%0'\nnot found"), [Prop.toString(p)]);
              }
              It.from(steps).push(Step.mk(q, reason));
            }
            default: return fail(
              _("'0'\nis not an implication"), [Prop.toString(s)]);
          }
        }
      }
      case IA:
        final tx = _("Disjunction introduction is no aplicable to\n%0");
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case C(p, q): switch (p){
              case N(p1): It.from(steps).push(Step.mk(Prop.mkA(p1, q), reason));
              default: return fail(tx, [Prop.toString(s)]);
            }
            default: return fail(tx, [Prop.toString(s)]);
          }
        }
      case EA:
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case A(p, q): It.from(steps).push(Step.mk(
                Prop.mkC(Prop.mkN(p), q), reason
              ));
            default: return fail(
              _("%0\nis not a disjunction"), [Prop.toString(s)]
            );
          }
        }
      case IK:
        final tx = _("Conjunction introduction is no aplicable to\n%0");
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case N(p): switch (p){
              case C(p2, q): switch (q) {
                case N(q2): It.from(steps).push(Step.mk(Prop.mkK(p2, q2), reason));
                default: return fail(tx, [Prop.toString(s)]);
              }
              default: return fail(tx, [Prop.toString(s)]);
            }
            default: return fail(tx, [Prop.toString(s)]);
          }
        }
      case EK:
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case K(p, q): It.from(steps).push(Step.mk(
                Prop.mkN(Prop.mkC(p, Prop.mkN(q))), reason
              ));
            default: return fail(
              _("%0\nis not a conjunction"), [Prop.toString(s)]
            );
          }
        }
      case IE:
        final tx = _("Equivalence introduction is no aplicable to\n%0");
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case K(p, q): switch (p){
              case C(p1, q1): switch (q) {
                case C(p2, q2):
                  if (Prop.eq(p1, q2) && Prop.eq(q1, p2)) {
                    It.from(steps).push(Step.mk(Prop.mkE(p1, q1), reason));
                  } else {
                    return fail(tx, [Prop.toString(s)]);
                  }
                default: return fail(tx, [Prop.toString(s)]);
              }
              default: return fail(tx, [Prop.toString(s)]);
            }
            default: return fail(tx, [Prop.toString(s)]);
          }
        }
      case EE:
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case E(p, q): It.from(steps).push(Step.mk(
                Prop.mkK(Prop.mkC(p, q), Prop.mkC(q, p)), reason
              ));
            default: return fail(
              _("%0\nis not an equivalence"), [Prop.toString(s)]
            );
          }
        }
      case ID:
        final tx = _("Exclusion introduction is no aplicable to\n%0");
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case E(p, q): switch (p){
              case N(p1): It.from(steps).push(Step.mk(Prop.mkD(p1, q), reason));
              default: return fail(tx, [Prop.toString(s)]);
            }
            default: return fail(tx, [Prop.toString(s)]);
          }
        }
      case ED:
        switch (getLastStep()) {
          case Error(e): return fail0(e);
          case Ok(s): switch (s) {
            case D(p, q): It.from(steps).push(Step.mk(
                Prop.mkE(Prop.mkN(p), q), reason
              ));
            default: return fail(
              _("%0\nis not an exclusion"), [Prop.toString(s)]
            );
          }
        }
    }
    return Ok(newSteps.to());
  }

}
