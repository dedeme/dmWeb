// Copyright 15-Nov-2019 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

"../dm/client" import
"../dm/wg" import
"../dm/location" import
"../common/libs" import
"chpass" import

( @+m:
  "update" (this,show) map,put+
  "editId" "" map,put+

  "idIn" "pathIn" wg,field { att: id "IdIn", att: size "20" } ui,$+ map,put+
  "pathIn" "idIn" wg,field { att: id "pathIn", att: size "60" } ui,$+ map,put+
@-m) new =>

( @+m:: # Pg# =
  Pg# .view { removeAll } [
    "div" { class: "title", html: ("Libraries":_) } []
    "div" { html: "&nbsp;" } []
    (Pg# this,table)
    "div" { html: "&nbsp;" } []
    "div" { style: "text-align:center"} [
      ((Pg# this,chLang.) wg,link) {
        class: "link"
        html: (
          "Change Language to %0":_
          (Pg# .lang "es" == ("EN") ("ES") elif) __
        )
      }
      "span" { text: " | " } []
      ((Pg# this,chPass.) wg,link) {
        class: "link",
        text: ("Change Password":_)
      }]]
  ui,$
@-) show =>

( @+m:: # Pg# =;
  Pg# .editId : id# =
  id# "" != : mod? =
  Pg# .showAll? ("out") ("in") elif : showAllImg =
  "table" {
    att: class "border"
    att: align "center"
    style: "background-color: rgb(255, 250, 250)"
  }
  (
    "tr" {} [
      "td" {} [ ("new" wg,img) { style: "vertical-align:-15%" } ]
      "td" {
        att: colspan "2"
        style: "text-align:center"
      } [
        "button" {
          disabled: (mod? (1) (0) elif)
          att: id "newEnterBt"
          style: "width: 70px"
          on: {click: (
            Pg#
            "#nameIn" ui,$+ (value) ui,prop str,trim
            "#pathIn" ui,$+ (value) ui,prop str,trim
              this,newPath.
          )}
        } [ ("enter" wg,img) { style: "vertical-align:-10%" }]]
      "td" {} [
        ("pathIn" wg,field) {
          disabled: (mod? (1) (0) elif)
          att: id "nameIn"
          att: size "20"
        }]
      "td" {} [
        ("newEnterBt" wg,field) {
          disabled: (mod? (1) (0) elif)
          att: id "pathIn"
          att: size "60"
        }]
      "td"
    ]
    "tr" {} [
      "td" { style: "width: 18px" } [
        ( mod?
          ( showAllImg wg,lightImg)
          ( (Pg# this,chShowAll.) wg,link {} [ (showAllImg wg,img) ] ui,$+)
          elif
        )]
      "td" { style: "width: 18px" }
      "td" { style: "width: 18px" }
      "td" { html: ("&nbsp;&nbsp;<b>" "Name":_ "</b>" + +) }
      "td" { html: ("&nbsp;&nbsp;<b>" "Path":_ "</b>" + +) }
      "td"
    ]
    Pg# .libs lst,size
    ( Pg# .libs
      ( L =
        Pg# .showAll?
          L libs,show? : L libs,exists? : &&
          ||
      ) lst,filter
      ( @+l R =
        R libs,id : lid# =
        R libs,lpath : lpath# =
        R libs,show? : show?# =
        R libs,exists? : exists?# =

        "tr" {} [
          "td" {} [
            (
              mod?
              (
                id# lid# ==
                ( "blank" wg,lightImg)
                ( show?# ("out") ("in") elif wg,lightImg)
                elif
              )
              (
                exists?#
                (
                  (Pg# lid# this,showPath.) wg,link {} [
                    (show?# ("out") ("in") elif wg,img) ] ui,$+
                )
                ( "in" wg,lightImg)
                elif
              )
              elif
            )]
          "td" { style: "text-align:center;" } [
            (
              mod?
              (
                id# lid# ==
                (
                  (Pg# this,modifyCancel.) wg,link {} [
                    ("cancel" wg,img) ] ui,$+
                )
                ( "edit" wg,lightImg)
                elif
              )
              (
                (Pg# lid# this,modifyBegin.) wg,link {} [
                  ("edit" wg,img) ] ui,$+
              )
              elif
            )]
          "td" { style: "text-align:center;" } [
            (
              mod?
              (
                id# lid# ==
                (
                  (Pg# lid# lpath# show?# this,modify.) wg,link {} [
                    ("enter" wg,img) ] ui,$+
                )
                ( "delete" wg,lightImg)
                elif
              )
              (
                (Pg# lid# this,deletePath.) wg,link {} [
                  ("delete" wg,img) ] ui,$+
              )
              elif
            )]
          "td" { class: "border"} [
            (
              mod? : Pg# .editId lid# == : &&
              ( Pg# .idIn { value: lid# } ui,$+)
              (
                "span" {
                  text:
                    (lid# str,len 20 > (lid# 17 str,left "..." +) (lid#) elif)
                } ui,$+
              )
              elif
            )
          ]
          "td" { class: "border"} [
            (
              mod? : Pg# .editId lid# == : &&
              ( Pg# .pathIn { value: lpath# } ui,$+)
              (
                "span" {
                  text: (
                    lpath# str,len 60 >
                    ("..." lpath# -57 str,right +)
                    (lpath#)
                    elif
                  )
                } ui,$+
              )
              elif
            )
          ]
          "td" {} [ (exists?# ("well") ("error") elif wg,img) ]] ui,$+
      @-<Element>) lst,map
      dup lst,size (run) (pop) elif
    )
    ( "tr" {} [
        "td" {
          att: colspan "6"
          class: "border"
          style: "text-align: center"
          text: ("There are no libraries":_) }]
    )
    elif
  ) data
   ui,$+
@-<Element>) table =>

// Control ---------------------------------------------------------------------

( @+ss:: id =; chars =
  ""
  chars str,len
  ( i =;
    id : chars i str,get str,index : -1 !=
    (
      pop
      "Name '%0' contains '%1'.\nCharacters '%2' are not valid.":_
        [id, chars i str,get, chars] __
      break;
    )
    if
  )
  for
@-s) validateChar. =>

( @+ls:: id =; Ids =
  id "" ==
  ( "Name is missing":_)
  (
    id " " str,index -1 !=
    ( "Name '%0' contains blanks":_ [id] __)
    ( "=@/?" id this,validateChar.)
    elif
  )
  elif
  dup "" ==
  (
    Ids (id ==) lst,any?
    ( pop "Name '%0' is repeated":_ [id] __)
    if
  )
  if
@-s) validateId. =>

( @+s:: p =
  p "" ==
  ( "Path is missing":_)
  (
    p "/" str,starts?
    (
      p wrap,ref P =
      (P >> str,len 1 > : P >> "/" str,ends? &&) (P (-1 str,left) ^^) while
      P >> "/" == ("Path is '/'") ("") elif
    )
    ( "Path '%0' does not start with '/'":_ [p] __)
    elif
  )
  elif
@-s) validatePath. =>

( @+lss lpath =; id =; Ids =
  Ids id this,validateId. dup "" ==
  ( pop lpath this,validatePath.)
  if
@-s) validateIdPath. =>

( @+m:: Pg =
  Pg .client
  {
    "page": "paths" js,ws
    "rq": "setLang" js,ws
    "lang": Pg .lang "es" == ("en") ("es") elif js,ws
  } map,from
  ( pop location,reload)
  client,send
@-) chLang. =>

( @+m:: Pg =
  Pg chpass,new chpass,show
@-) chPass. =>

( @+m:: Pg =
  Pg .client
  {
    "page": "paths" js,ws
    "rq": "setShowAll" js,ws
    "showAll?": Pg .showAll? (0) (1) elif js,wb
  } map,from
  ( pop reload!)
  client,send
@-) chShowAll. =>

( @+mss:: # lpath =; id =; Pg# =
  Pg# .libs libs,readIds : id: lpath : this,validateIdPath.

  dup "" ==
  (
    pop
    Pg# .client
    {
      "page": "paths" js,ws
      "rq": "addPath" js,ws
      "id": id js,ws
      "path": lpath js,ws
    } map,from
    ( Rp =
      Pg# : "libs" : Rp .libs libs,fromJs : map,put
      reload!
    )
    client,send
  )
  ( sys,alert)
  elif
@-) newPath. =>

( @+ms:: id =; Pg =
  Pg .client
  {
    "page": "paths" js,ws
    "rq": "showPath" js,ws
    "id": id js,ws
  } map,from
  ( pop reload!)
  client,send
@-) showPath. =>

( @+ms:: id =; Pg =
  Pg "editId" id map,put
  Pg Pg .update run
  Pg .idIn { focus } ui,$
@-) modifyBegin. =>

( @+m:: Pg =
  Pg "editId" "" map,put
  Pg Pg .update run
@-) modifyCancel. =>

( @+mssi:: show? =; lpath =; id =; Pg =
  Pg .idIn (value) ui,prop str,trim : newId =
  Pg .pathIn (value) ui,prop str,trim : newPath =

  id newId == : lpath newPath == : &&
  ( Pg this,modifyCancel.)
  (
    id newId ==
    ( newPath this,validatePath.)
    ( Pg .libs libs,readIds :  newId : newPath : this,validateIdPath.)
    elif : err =

    err "" ==
    (
      Pg .client
      {
        "page": "paths" js,ws
        "rq": "modify" js,ws
        "id": id js,ws
        "newId": newId js,ws
        "dpath": newPath js,ws
        "show?": show? js,wb
      } map,from
      ( pop reload!)
      client,send
    )
    ( err sys,alert)
    elif
  )
  elif
@-) modify. =>

( @+ms:: id =; Pg =
  "Delete %0?":_ (id) __ sys,confirm?
  (
    Pg .client
    {
      "page": "paths" js,ws
      "rq": "del" js,ws
      "id": id js,ws
    } map,from
    ( pop reload!)
    client,send
  )
  if
@-) deletePath. =>
