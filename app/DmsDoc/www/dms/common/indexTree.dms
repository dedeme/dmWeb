// Copyright 20-Nov-2019 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

"serial" import

[
  ["tree": (), (this,treeFromJs.), (this,treeToJs.)]
  ["id": "", (js,rs), (js,ws)]
  ["path": "", (js,rs), (js,ws)]
  ["doc": "", (js,rs), (js,ws)]
] Base. =

( @+osss:: doc =; lpath =; id =; Tree =
  this,Base. serial,new
  "id" id map,put+
  "path" lpath map,put+
  "doc" doc map,put+
  "tree" Tree map,put+
@-m) new =>
/// @lss -> @m
///   id: Node name
///   path: File path to place in URL
///   doc: Node documentation
///   Tree: Option
///     - None: Node is file
///     - Some @l: Node is directory and @l is a list of indexTree's

( @+o
  ( (this,toJs) lst,toJs)
  ( js,wn)
  wrap,option
@-s) treeToJs. =>

( @+s:: s =
  s js,null?
  ( wrap,none)
  ( s (this,fromJs) lst,fromJs wrap,some)
  elif
@-o) treeFromJs. =>

( @+m
  this,Base. serial,toJs
@-s) toJs =>
/// @m -> @s

( @+s
  this,Base. serial,fromJs
@-m) fromJs =>
/// @s -> @m

( @+m:: T =
  T .tree
  (
    ( @+mm:: T2 =; T1 =
      T1 .tree wrap,some?
      ( @+
        T1 this,sort
        T2 .tree wrap,some?
        (
          T2 this,sort;
          T1 .id : T2 .id : >
        )
        ( 1)
        elif
      @-i)
      ( @+
        T2 .tree wrap,some?
        ( T2 this,sort; 0)
        ( T1 .id : T2 .id : >)
        elif
      @-i)
      elif
    @-i)
    lst,sort
  )
  ()
  wrap,option
@-) sort =>

( @+m
  ( @+ms:: indent =; T =
    T .tree
    (
      "${indent}${T .id}:\n"
      ( T =; seed =
        seed :: T : indent "  " + : toStr1 :: +
      )
      lst,reduce
    )
    ( "${indent}${T .id}: ${T .doc}\n")
    wrap,option
  @-s) toStr1 =>

  "" toStr1
@-s) toStr =>
