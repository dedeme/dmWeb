// Copyright 27-Sep-2019 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

"../../dm/cgi" import
"../../dm/ext" import

( @+mss:: version =; appName =; Rq =

  ( // () -> String
    time,now time,toDate
  ) mkDate =>

  ( // () -> String
    time,now time,toDateTime
  ) mkTime =>

  ( // () -> ()
    cgi,home "tmp" path,+ dup
    file,del
    file,mkdir
  ) clearTmp =>

  ( // () -> List<String>
    cgi,home "backups" path,+ file,dir
  ) readBackups =>

  ( @+
    time,now : t0 =
    t0 -7 time,addDays : t1 =
    t0 time,broke : TmBk =
    TmBk .day : TmBk .month : TmBk .year 1 - : time,newDate : t2 =

    t1 time,toDate : d1 =
    t2 time,toDate : d2 =

    "        " wrap,ref : Previous =
    cgi,home "backups" path,+ file,dir dup (>) lst,sort
    ( f =
      f path,onlyName : name =

      ( name d2 > !)
      (
        name 6 str,left : Previous >> 6 str,left : ==
        ( cgi,home "backups" f path,+ path,+ file,del )
        if
      )
      else
      ( name d1 > !)
      (
        name 4 str,left : Previous >> 4 str,left : ==
        ( cgi,home "backups" f path,+ path,+ file,del )
        if
      )
      else
      if

      Previous name <<
    )
    lst,each
  @-) filterBackups =>
  /// @ -> @

  ( // () -> List<String>
    cgi,home "trash" path,+ file,dir
  ) readTrash =>

  ( // () -> ()
    cgi,home "data" path,+
      cgi,home "trash" mkTime ".zip" + path,+ path,+
        ext,zip
  ) toTrash =>

  ( version =; appName =  // (String, String) -> String
    cgi,home "tmp" "back.zip" path,+ path,+ : source =
    cgi,home "tmp" path,+ : target =
    source target ext,unzip

    cgi,home "tmp" "data" "version.txt" path,+ path,+ path,+ : fversion =
    ( fversion file,exists? !)
    ( "restore:version does not exist":_)
    else
    ( version fversion file,read ==)
    ( "")
    else
    ( "restore:version is wrong":_)
    if
  ) unzip =>

  // Start ---------------------------------------------------------------------

  Rq "rq" map,has? ! ("Field 'rq' is missing":_ lfail) if
  Rq .rq js,rs : rq =

  ( "clearTrash" rq ==)
  (
    cgi,home "trash" path,+ : dir =
    dir file,del
    dir file,mkdir
    cgi,none
  )
  else
  ( "restoreTrash" rq ==)
  (
    Rq .file js,rs : f =
    cgi,home "data" path,+ : dataDir =
    cgi,home "trash" f path,+ path,+ : backupFile =

    toTrash
    dataDir file,del
    backupFile cgi,home ext,unzip
    cgi,none
  )
  else
  ( "autorestore" rq ==)
  (
    Rq .file js,rs : f =
    cgi,home "data" path,+ : dataDir =
    cgi,home "backups" f path,+ path,+ : backupFile =

    toTrash
    dataDir file,del
    backupFile cgi,home ext,unzip
    cgi,none
  )
  else
  ( "restoreEnd" rq ==)
  (
    appName version unzip : err =
    err "" ==
    (
      cgi,home "data" path,+ : dataDir =
      cgi,home "tmp" "data" path,+ path,+ : tmpDataDir =
      toTrash
      dataDir file,del
      tmpDataDir dataDir file,rename
      clearTmp
    )
    if
    { "fail": err js,ws } map,from cgi,ok
  )
  else
  ( "restoreAbort" rq ==)
  (
    clearTmp
    cgi,none
  )
  else
  ( "restoreAppend" rq ==)
  ( Rq .data js,rs b64,decodeBytes : Bs =
    cgi,home "tmp" "back.zip" path,+ path,+ file,aopen dup
    Bs file,writeBin
    file,close
    cgi,none
  )
  else
  ( "restoreStart" rq ==)
  (
    clearTmp
    cgi,home "tmp" "back.zip" path,+ path,+ file,wopen file,close
    cgi,none
  )
  else
  ( "logout" rq ==)
  (
    cgi,home "data" path,+
      cgi,home : "backups" : mkDate ".zip" + : path,+ path,+
        ext,zip
    filterBackups
    cgi,none
  )
  else
  ( "backup" rq ==)
  (
    appName "Backup" mkDate ".zip" + + + : f =
    cgi,home "data" path,+
      cgi,home "tmp" f path,+ path,+
        ext,zip
    {"name": f js,ws} map,from cgi,ok
  )
  else
  ( "lists" rq ==)
  (
    {
      "backups": readBackups (js,ws) lst,map js,wa
      "trash": readTrash (js,ws) lst,map js,wa
    } map,from cgi,ok
  )
  else
  ( "Value '%0' not allowed for 'rq'":_ [rq] __ lfail)
  if
@-s) process =>
/// (String, String, Obj<JSON>) -> String
