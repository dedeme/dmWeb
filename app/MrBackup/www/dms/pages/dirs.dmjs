// Copyright 25-Dic-2019 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Pools page.

"../i18n" import
"../dm/client" import
"../dm/wg" import
"../dm/location" import
"../wgs/newDir" import
"../wgs/dirRow" import
"../common/dirData" import

( @+m # Pg# =
  Pg#
  "newDir" Pg# (this,activateNewDir) (this,addNewDir) newDir,new map,put+

  "dirsDiv" "div" ui,$+ map,put+
@-m) new =>
/// @m::page -> @m::page

( @+m:: Pg =
  Pg .view { removeAll } [
    "div" { style: "text-align:center" } [
      "div" { class: "head", html: ("New":_) }
      "table" { class: "frame"; att: align "center" } [ "tr" {} [ "td" {} [
        (Pg .newDir newDir,widget) ]]]]
    "div" { style: "text-align:center" } [
      "div" { class: "head", html: ("Directories":_) } []
      (Pg .dirsDiv) ]
  ] ui,$

  Pg this,update.
@-) show =>
/// @m::page -> @

( @+m:: Pg =
  Pg .view { removeAll } [
    "table" { class: "frame"; att: align "center" } [ "tr" {} [
      "td" { html: ("Pools in bad condition":_) }
  ]]] ui,$
@-) poolsWrong. =>

( @+ml:: Dirs =; Pg =
  Dirs lst,size
  (
    Dirs (R2 =; R1 =; R1 .id str,toUpper : R2 .id str,toUpper : >) lst,sort
    Dirs
    ( Row =
      Pg Row
        (this,execBk)
        (this,delDir) : (this,modifyDir)
        (this,delPath) : (this,modifyPath)
        (this,showDir)
        dirRow,new dirRow,widget
    )
    lst,map : Rows =

    "table" { class "white"; att: align "center"} Rows ui,$+ : Table =
    Pg .dirsDiv { removeAll } [
      (Table)
    ] ui,$
  )
  (
    Pg .dirsDiv { removeAll } [
    "table" { class: "frame"; att: align "center" } [ "tr" {} [
      "td" { html: ("Without directories":_) }
    ]]] ui,$
  )
  elif
@-) poolsOk. =>

// Control ---------------------------------------------------------------------

( @+s:: id =;
  id "" ==
  ( "Name is missing.":_)
  (
    "" wrap,ref : R =
    id str,len
    ( i =
      id i str,get : ch =
      ch "_" !=
      ch "0" < : ch "9" > || &&
      ch "A" < : ch "Z" > || &&
      ch "a" < : ch "z" > || &&
      ( R "Character '%0' is not allowed":_ [ch] __ <<; break)
      if
    )
    for
    R >>
  )
  elif
@-s) validateId. =>

( @+m:: Pg# =
  Pg# .client
  {
    "page": "Dirs" js,ws
    "rq": "idata" js,ws
  } map,from
  ( Rq =
    Rq .poolsOk js,rb : poolsOk =
    Rq .dirs (dirData,fromJs) lst,fromJs : Dirs =

    poolsOk
    ( Pg# Dirs this,poolsOk.)
    ( Pg# this,poolsWrong.)
    elif
  )
  client,send
@-) update. =>

( @+m:: Pg =
  Pg .newDir newDir,activate

@-) activateNewDir =>

( @+ms:: id =; Pg# =
  id this,validateId. dup "" ==
  ( pop
    Pg# .client
    {
      "page": "Dirs" js,ws
      "rq": "add" js,ws
      "id": id js,ws
    } map,from
    (
      .ok js,rb
      (
        "Directory correctly added.":_ sys,alert
        location,reload
      )
      ( "There was a fail.\n":_ "See log.":_ + sys,alert)
      elif
    )
    client,send
  )
  ( sys,alert)
  elif
@-) addNewDir =>

( @+m:: # Wg# =
  Wg# .pg : Pg# =
  Wg# .row : Row# =

  "Make '%0' backup?":_ [ Row# .id ] __ sys,confirm?
  (
    Wg# .exec {removeAll} [ ("wait.gif" wg,img) ] ui,$
    Pg# .client
    {
      "page": "Dirs" js,ws
      "rq": "execBackup" js,ws
      "id": Row# .id js,ws
    } map,from
    ( Rq# =
      chan,new : Ch =
      (
        Pg# .client
        {
          "page": "Dirs" js,ws
          "rq": "execBackup2" js,ws
          "tmp": Rq# .ftmp
        } map,from
        ( Ch chan,send)
        client,send
      ) Cb* =
      Cb* sys,go

      ( Rq = ;
        Rq map,size 0 ==
        ( 200 (Cb* sys,go) sys,delay)
        (
          Rq .ok js,rb
          ( "Backup finished.":_ sys,alert)
          ( "There was a fail.\n":_ "See log.":_ + sys,alert)
          elif
          Wg# .exec {removeAll} [ (Wg# .bkRun) ] ui,$
        )
        elif
      ) Ch chan,recv
    )
    client,send
  )
  if
@-) execBk =>

( @+m:: Wg =
  Wg .pg : Pg =
  Wg .row : Row =

  "Delete '%0'?":_ [ Row .id ] __ sys,confirm?
  (
    Pg .client
    {
      "page": "Dirs" js,ws
      "rq": "delDir" js,ws
      "id": Row .id js,ws
    } map,from
    (
      .ok js,rb !
      (
        "A fail happened deleting '%0'.\n":_ [ Row .id ] __
          "See log.":_ +
          sys,alert
      )
      if

      location,reload
    )
    client,send
  )
  if
@-) delDir =>

( @+m:: Wg =
  Wg .pg : Pg =
  Wg .row : Row =
  Row .id : oldId =
  Wg .idInput (value) ui,prop : newId =

  oldId newId !=
  (
    newId this,validateId. dup "" ==
    ( pop
      Pg .client
      {
        "page": "Dirs" js,ws
        "rq": "modifyDir" js,ws
        "oldId": oldId js,ws
        "newId": newId js,ws
      } map,from
      (
        .ok js,rb
        ( "Directory correctly modified.":_ sys,alert)
        ( "There was a fail.\nSee log." sys,alert)
        elif
        location,reload
      )
      client,send
    )
    ( sys,alert)
    elif
  )
  ( location,reload)
  elif
@-) modifyDir =>

( @+m:: Wg =
  Wg .pg : Pg =
  Wg .row : Row =

  "Delete '%0' path?":_ [ Row .id ] __ sys,confirm?
  (
    Pg .client
    {
      "page": "Dirs" js,ws
      "rq": "delPath" js,ws
      "id": Row .id js,ws
    } map,from
    (
      .ok js,rb
      ( "Path correctly deleted.":_ sys,alert)
      ( "There was a fail.\nSee log." sys,alert)
      elif
      location,reload
    )
    client,send
  )
  if
@-) delPath =>

( @+m:: Wg =
  Wg .pg : Pg =
  Wg .row : Row =
  Row .id : id =
  Wg .ptInput (value) ui,prop : dpath =

  dpath "" ==
  ( "Path is empty" sys,alert)
  (
    Pg .client
    {
      "page": "Dirs" js,ws
      "rq": "modifyPath" js,ws
      "id": id js,ws
      "dpath": dpath js,ws
    } map,from
    (
      .ok js,rb
      ( "Path correctly modified.":_ sys,alert)
      ( "There was a fail.\nSee log." sys,alert)
      elif
      location,reload
    )
    client,send
  )
  elif
@-) modifyPath =>

( @+m:: Wg =
  Wg .pg : Pg =
  Wg .row : Row =

  Pg .client
  {
    "page": "Dirs" js,ws
    "rq": "showDir" js,ws
    "id": Row .id js,ws
  } map,from
  ()
  client,send
@-) showDir =>
