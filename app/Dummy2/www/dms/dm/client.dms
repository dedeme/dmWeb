// Copyright 28-Oct-2019 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

300 : klen. =

(
  this,klen. cryp,key
) crypPass. =>

( @lsi :: # FExpired# =; appName# =; dmCgi?# =
  {
    "dmCgi?": dmCgi?#
    "appName": appName#
    "FExpired": FExpired#
    "connectionId": ""
  } data
@l) new =>
/// (Int, String, () -> Void) -> Client
///   dmCgi?: If is 'true' server is accessed through 'dmcgi'.
///   appName: Used to customize LocalStore.
///   FExpired: Function to launch expired page.
///   return: Object with following fields:
///     - dmCgi?
///     - appName
///     - FExpirec
///     - connectionId (String): Connection identifier

( Cl =
  "Client_sessionId_" : Cl .appName : + store,take
  ()
  ( "0" b64.encode)
  wrap,option
) sessionId. =>

( value =; Cl =
  "Client_sessionId_" Cl .appName + : value : store,put
) setSessionId. =>

( Cl =
  "Client_key_" : Cl .appName : + store,take
  ()
  ( "0" b64.encode)
  wrap,option
) key. =>

( value =; Cl =
  "Client_key_" Cl .appName + : value : store,put
) setKey. =>

( Cl =
  "Client_user_" : Cl .appName : + store,take
  ()
  ( "0" b64.encode)
  wrap,option
) user. =>

( value =; Cl =
  "Client_user_" Cl .appName + : value : store,put
) setUser. =>

( # Fn# =; rq# =; Cl# = //  rq is in B64
  Cl# .dmCgi? ("cgi-bin/ccgi.sh") ("") elif
    Cl# .appName  ":" rq# + +
      Fn#
      com,localRq
) sendServer. =>

( # fn# =>; Cl# =
  Cl#
  dup this,sessionId. : sessionId# =

  sessionId#
    (
      ( rp# =
        (
          rp# sessionId# cryp,decryp js,ro : Jsrp# =
          Jsrp# .key js,rs : key# =
          key# "" : ==
          ( 0 fn#)
          (
            Jsrp# .connectionId js,rs : cId# =
            Cl# key# this,setKey.
            Cl# "connectionId" cId# obj,put
            1 fn#
          )
          elif
        )
        ( E =
          "RAW SERVER RESPONSE:\n${rp#}\n"
            "CLIENT ERROR:\n${E exc,msg}\n" + sys,log
        )
        try
      )
      ( e =
        "CLIENT ERROR:\n${e}" sys,log
      )
      wrap,either
    ) this,sendServer.
) connect =>
/// (Client, Int -> Void) => Void
///   Cl: Client
///   fn: Callback that receives '1' or '0' acording as conncection was
///       successfuly or not.

( # fn# =>; expiration =; pass =; user# =; Cl# =
  Cl# .appName this,crypPass. : key# =
  pass this,crypPass. : p# =
  expiration ("1") ("0") elif : exp =

  Cl# ":" "${user#}:${p#}:${exp}" key# cryp,cryp +
    (
      ( rp# =
        (
          rp# key# cryp,decryp js,ro : Jsrp# =
          Jsrp# .sessionId js,rs : sessionId# =
          sessionId# "" : ==
          ( 0 fn#)
          (
            Jsrp# .key js,rs : newKey# =
            Cl# newKey# this,setKey.
            Cl# sessionId# this,setSessionId.
            Cl# user# this,setUser.
            1 fn#
          )
          elif
        )
        ( E =
          "RAW SERVER RESPONSE:\n${rp#}\n"
            "CLIENT ERROR:\n${E exc,msg}\n" + sys,log
        )
        try
      )
      ( e =
        "CLIENT ERROR:\n${e}" sys,log
      )
      wrap,either
    ) this,sendServer.
) authentication =>
