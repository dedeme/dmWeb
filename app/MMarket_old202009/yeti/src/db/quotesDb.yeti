// Copyright 26-Apr-2020 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Quotes data base.
module db.quotesDb;

load es.dm.std;
{(^/)} = load es.dm.path;
file = load es.dm.file;
sync = load es.dm.sync;
load std;
quote = load data.quote;
qtable = load data.qtable;
cts = load data.cts;
nick = load data.nick;
nicksTb = load db.nicksTb;
matrix = load data.matrix;
log = load db.log;

(
  var path = "";

  nickPath nk = path ^/ "\(nk).tb";

  read' lk nickName =
    ( path = nickPath nickName;
      if file.exists? path then
        qs = file.mapLines path quote.fromStr |> filter do q: not none? q done;
        if length qs != cts.historicQuotes then []
        else map optGet qs
        fi
      else
        []
      fi
    );

  mkQtable lk fnGetValue =
    ( nks = map do nk: nk.name done (nicksTb.selectedNicks lk);
      ncols = length nks;
      nrows = cts.historicQuotes;
      mx = matrix.mk2 nrows ncols;

      for (map2 pair [0..1000] nks) do ixNk:
        ix = ixNk.fst;
        nk = ixNk.snd;
        case read' lk nk of
        [] :
          mmFail "Quotes of nick \(nk) wrong or not found";
        qs :
          for (map2 pair [0..10000] (reverse qs)) do jxQ:
            jx = jxQ.fst;
            q = jxQ.snd;
            mx[jx][ix] := fnGetValue q
            done
        esac
        done;

      qtable.mk (array nks) mx
    );

{
  /// Initializes configuration table.
  ///
  /// Arguments:
  ///   parent - Parent directory.
  init parent
  is string -> () =
    path := parent ^/ "quotes";
    if not file.exists? path
    then
      file.mkdir path
    fi,

  /// Reads quotes of a company.
  ///
  /// If an error happens the returned list is empty.
  ///
  /// The order of quotes is from after to before.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   nickName - Nick.
  read lk nickName
  is sync.t -> string -> list<quote.t> =
    read' lk nickName,

  /// Returns company model quotes.
  ///
  /// If an error happens the returned list is empty.
  ///
  /// The order of quotes is from after to before.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  readModel lk
  is sync.t -> list<quote.t> =
    case nicksTb.getModel lk of
    Some nk : read lk nk.name;
    None () : []
    esac,

  /// Set quotes of a company. If operation fails return 'false'.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   nickId - Nick identifier.
  ///   qs - Quotes to update.
  setQuotes lk nickId qs
  is sync.t -> number -> list<quote.t> -> boolean =
    case nicksTb.getNick lk nickId of
    Some nk :
      if length qs != cts.historicQuotes then
        log.error lk
          ( "\(nk.name): Wrong quotes numuber.\n" ^
            "Expected: \(cts.historicQuotes).\nActual: \(length qs)");
        false
      else
        file.writeAll (nickPath nk.name)
                      (strJoin "\n" (map do q: quote.toStr q done qs));
        true
      fi;
    None () :
      log.error lk "Nick with id '\(nickId)' not found";
      false
    esac,

  /// Returns a qtable of opens of the selected companies.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  opens lk
  is sync.t -> qtable.t =
    mkQtable lk do q: q.open done,

  /// Returns a qtable of closes of the selected companies.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  closes lk
  is sync.t -> qtable.t =
    mkQtable lk do q: q.close done,

  /// Returns a Hash[nick, volume] with the 100 last days volume average of
  /// every nick in "nicks".
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   nicks - Nick list.
  volumes lk nicks
  is sync.t -> list<nick.t> -> hash<string, number> =
    r = [:];
    for (map (.name) nicks) do nk:
      lst = read lk nk |>
            take cts.quotesVolume |>
            filter do q: q.max >= 0 and q.min >= 0 and q.vol >= 0 done |>
            map do q: (q.max + q.min) * q.vol / 2 done |>
            sort;

      {sm, n} = fold do { sm, n } v:
                       { sm = sm + v, n = n + 1 }
                     done
                     { sm = 0, n = 0 }
                     (take (length lst / 2) lst);
      r[nk] := if n > 0 then sm / n else 0 fi
      done;
    r,

  /// Adds a nick. If nick already exists, logs an error and returns "false".
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   nickName - Name of nick to add.
  addNick lk nickName
  is sync.t -> string -> boolean =
    fpath = nickPath nickName;
    if file.exists? fpath then
      log.error lk "File \(fpath) already exists";
      false
    else
      file.writeAll fpath "";
      true
    fi,

  /// Removes nick with name "nickName".
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   nickName - Name of nick to add.
  delNick lk nickName
  is sync.t -> string -> () =
    file.del (nickPath nickName),

  /// Modify nick name.
  ///
  /// If "newName" already exists or "oldName" does not exists, it does nothing.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   oldName - Name of nick to modify.
  ///   newName - New name of nick.
  modifyNickName lk oldName newName
  is sync.t -> string -> string -> () =
    op = nickPath oldName;
    np = nickPath newName;
    if file.exists? op and not file.exists? np then
      file.mv op np
    fi,

  /// Checks quotes in text format.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   qsTx - Quotes in text format.
  ///
  /// Notes:
  ///   Returns:
  ///   : error?   - 'true' if an error happend. In this case "qs" = [].
  ///   : warning? - 'true' if some quotes were corrected.
  ///   : qs       - Quotes, corrected if necessary.
  check lk qsTx
  is sync.t -> string ->
    { error? is boolean, warning? is boolean, qs is list<quote.t> } =
    mkQs err qs qsT = case qsT of
                      qT::qsT' :
                        case quote.fromStr qT of
                        Some q :
                          mkQs err (q::qs) qsT';
                        None () :
                          log.error lk "Wrong quote: \(qT)";
                          mkQs true qs qsT'
                        esac;
                      _ : { error? = err, qs = reverse qs }
                      esac;
    { error?, qs } = mkQs false [] (csplit "\n"qsTx);
    { error?, mqs } = if error? then
                        { error?, mqs = [] }
                      else
                        mqs = readModel lk;
                        if empty? mqs then { error? = true, mqs }
                        else { error?, mqs }
                        fi
                      fi;
    if error? then
      { error?, warning? = false, qs = [] }
    else
      { errors = es1, qs } = quote.correctDates mqs qs;
      { errors = es2, qs } = quote.correct qs;
      es = es1 ++ es2;
      warning? = if empty? es then
                   false
                 else
                   log.error lk (strJoin "\n" es);
                   true
                 fi;
      { error?, warning?, qs}
    fi,

  /// Returns dates of nicks tables fron before to after. Its length is
  /// 'cts.historicQuotes'. If fails, returns an empty list.
  ///
  ///   lk - Synchronization lock.
  dates lk
  is sync.t -> list<string> =
    map (.date) (readModel lk) |> reverse,

  /// Checks quotes of a company.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   nickName - Nick name.
  ///
  /// Notes:
  ///   Returns:
  ///   : error?   - 'true' if an error happend.
  ///   : warning? - 'true' if some quotes were corrected.
  checkQs lk nickName
  is sync.t -> string ->
    { error? is boolean, warning? is boolean, qs is list<quote.t> } =
    qs = read lk nickName;
    error? = empty? qs;
    { error?, mqs } = if error? then
                        { error?, mqs = [] }
                      else
                        mqs = readModel lk;
                        if empty? mqs then { error? = true, mqs }
                        else { error?, mqs }
                        fi
                      fi;
    if error? then
      if empty? qs then
        log.error lk "Nick \(nickName): Without quotes"
      else
        log.error lk "Nick model \(nickName): Without quotes"
      fi;
      { error?, warning? = false, qs }
    else
      { errors = es1, qs } = quote.correctDates mqs qs;
      { errors = es2, qs } = quote.correct qs;
      es = es1 ++ es2;
      warning? = if empty? es then
                   false
                 else
                   log.error lk (strJoin "\n" ("Nick \(nickName):" :: es));
                   true
                 fi;
      { error?, warning?, qs}
    fi,
})
