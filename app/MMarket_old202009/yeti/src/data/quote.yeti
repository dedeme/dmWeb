// Copyright 20-Apr-2020 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Quote data.
module data.quote;

load es.dm.std;
json = load es.dm.json;
dec = load es.dm.dec;
{mostDupWith, mostDup, seqMost, seqCount, seqLast} = load es.dm.coll;
cts = load data.cts;

typedef t =
  { date is string,
    open is number,
    close is number,
    max is number,
    min is number,
    vol is number,
    err is boolean // Its value is 'true' if quote was manually modified.
  };

{
  /// Create a new quote.
  ///
  /// Arguments:
  ///   date - Date of quote in format "YYYYMMDD".
  ///   open - Open value.
  ///   close - Close value.
  ///   max - Maximum value.
  ///   min - Minimum value.
  ///   vol - Valume value.
  ///   err - 'true' if quote was modified manually.
  mk date open close max min vol err
  is string -> number -> number -> number -> number -> number -> boolean -> t =
    { date, open, close, max, min, vol, err },

  /// Serializes to JSON.
  ///
  /// Arguments:
  ///   q - Quote.
  toJs q
  is t -> json.t =
    json.wa
      [ json.ws q.date,
        json.wn q.open,
        json.wn q.close,
        json.wn q.max,
        json.wn q.min,
        json.wn q.vol,
        json.wb q.err
      ],

  /// Restores from JSON.
  ///
  /// Arguments:
  ///   js - JSON value.
  fromJs js
  is json.t -> t =
    a = array (json.ra js);
    { date = json.rs a[0],
      open = json.rn a[1],
      close = json.rn a[2],
      max = json.rn a[3],
      min = json.rn a[4],
      vol = json.rn a[5],
      err = json.rb a[6]
    },

  /// Returns a string representation of "q".
  ///
  /// Arguments:
  ///   q - Quote.
  toStr q
  is t -> string =
    "\(q.date):" ^
    "\(strJoin ":" (map (dec.toStr . dec.fix 4)
                        [q.open, q.close, q.max, q.min]))" ^
    ":\(int q.vol):\(q.err)",

  /// Returns a Quote from its string representation.
  ///
  /// Arguments:
  ///   s - Quote representation.
  fromStr s
  is string -> option<t> =
    case csplit ":" s of
    [d, o, c, mx, mn, v, e] :
      mk <$>
        if strLength d == 8 and dec.digits? d then Some d else None () fi <*>
        dec.fromStr(o) <*>
        dec.fromStr(c) <*>
        dec.fromStr(mx) <*>
        dec.fromStr(mn) <*>
        dec.fromStr(v) <*>
        if e == "true" then Some true
        elif e == "false" then Some false
        else None ()
        fi;
    _ :
      None ()
    esac,

  /// Returns the number of manual corrections in qs.
  ///
  /// Arguments:
  ///   qs - Quotes.
  manuals qs
  is list<t> -> number =
    fold do r q: if q.err then r + 1 else r fi done 0 qs,

  /// Checks maximum and minimum and returns a new quote corrected.
  ///
  /// If q.err = true, quote will not be corrected.
  ///
  /// If quote was corrected, its 'err' field is set to 'true'.
  ///
  /// Arguments:
  ///   q     - Quote to correct
  ///
  /// Notes:
  ///   Return is
  ///   : {
  ///   :   error: A message (e.g. Max > Min) if there was some error or
  ///   :          an empty string otherwise.
  ///   :   q : Quote corrected if neccessary.
  ///   : }
  correct1 q
  is t -> { error is string, q is t } =
    date = q.date;
    open = q.open;
    close = q.close;
    var max = q.max;
    var min = q.min;
    vol = q.vol;
    var err = q.err;

    var error = "";
    if not err then
      if open > max then
        max := open;
        error := "Open > Max"
      elif close > max then
        max := close;
        error := "Close > Max"
      elif open < min then
        min := open;
        error := "Open < Min"
      elif close < min then
        min := close;
        error := "Close < Min"
      fi
    fi;
    err := error != "" or err;

    { error, q = { date, open, close, max, min, vol, err } },

  /// Checks maximum and minimum and returns a new quote corrected.
  ///
  /// If last.err = true, quote will not be corrected.
  ///
  /// If quote was corrected, its 'err' field is set to 'true'.
  ///
  /// Arguments:
  ///   last - Quote to correct
  ///   previous - Quote previous to "last"
  ///
  /// Notes:
  ///   Return is
  ///   : {
  ///   :   error : A message (e.g. Close < Min) if there was some error or
  ///   :           an empty string otherwise.
  ///   :   q : Quote corrected if neccessary.
  ///   : }
  correct2 last previous
  is t -> t -> { error is string, q is t } =
    date = last.date;
    var open = last.open;
    var close = last.close;
    var max = last.max;
    var min = last.min;
    vol = last.vol;
    var err = last.err;
    open0 = previous.open;
    close0 = previous.close;
    max0 = previous.max;
    min0 = previous.min;

    var error = "";
    if not err and open0 >= 0 then
      if max0 < min0 then
        correct1 last
      else
        if open > max then
          if open == open0 and max != max0 then open := max else max := open fi;
          error := "Open > Max";
        elif close > max then
          if close == close0 and max != max0
          then close := max
          else max := close
          fi;
          error := "Close > Max";
        elif open < min then
          if open == open0 and min != min0 then open := min else min := open fi;
          error := "Open < Min";
        elif close < min then
          if close == close0 and min != min0
          then close := min
          else min := close
          fi;
          error := "Close < Min"
        fi;
        err := error != "" or err;
        { error, q = { date, open, close, max, min, vol, err } }
      fi
    elif not err then
      correct1 last
    else
      { error, q = last }
    fi,

  /// Checks increment (+-20%) and returns a new quote corrected.
  ///
  /// If last.err = true, quote will not be corrected.
  ///
  /// If quote was corrected, its 'err' field is set to 'true'.
  ///
  /// Arguments:
  ///   last - Quote to correct
  ///   previous - Quote previous to "last"
  ///
  /// Notes:
  ///   Return is
  ///   : {
  ///   :   error : A message (e.g. Min + 20%) if there was some error or
  ///   :           an empty string otherwise.
  ///   :   q : Quote corrected if neccessary (only 'err' field).
  ///   : }
  correct3 last previous
  is t -> t -> { error is string, q is t } =
    date = last.date;
    open = last.open;
    close = last.close;
    max = last.max;
    min = last.min;
    vol = last.vol;
    var err = last.err;
    open0 = previous.open;
    close0 = previous.close;
    max0 = previous.max;
    min0 = previous.min;

    var error = "";
    if not err and open0 >= 0 then
      if open > open0 * 1.2 then error := "Open +20%" fi;
      if close > close0 * 1.2 then error := "Close +20%" fi;
      if max > max0 * 1.2 then error := "Max +20%" fi;
      if min > min0 * 1.2 then error := "Min +20%" fi;

      if open < open0 * 0.8 then error := "Open -20%" fi;
      if close < close0 * 0.8 then error := "Close -20%" fi;
      if max < max0 * 0.8 then error := "Max -20%" fi;
      if min < min0 * 0.8 then error := "Min -20%" fi
    fi;
    err := error != "" or err;
    { error, q = { date, open, close, max, min, vol, err } },

  /// Corrects "qs" and returns a list with corrected quotes.
  ///
  /// Arguments:
  ///   qs - Historic quotes.
  ///
  /// Notes:
  ///   Return is:
  ///   : {
  ///   :   errors : A list with messages coming from correct1, correct2 and
  ///   :            correct3. If there was no error, it is an empty list.
  ///   :   qs : Quotes corrected if neccessary.
  ///   : }
  correct qs
  is list<t> -> { errors is list<string>, qs is list<t> } =
    qs' errors qs qs1 qs2 =
      case qs2 of
      q2::qs2' :
        q1 = head qs1;
        {error, q} = correct2 q1 q2;
        errors =
          if error != "" then "\(q.date): \(error)"::errors else errors fi;
        {error, q} = correct1 q;
        errors =
          if error != "" then "\(q.date): \(error)"::errors else errors fi;
        {error, q} = correct3 q q2;
        errors =
          if error != "" then "\(q.date): \(error)"::errors else errors fi;
        qs' errors (q::qs) (tail qs1) qs2';
      _ :
        case qs1 of
        q1::qs1' :
          {error, q} = correct1 q1;
          errors =
            if error != "" then "\(q.date): \(error)"::errors else errors fi;
          qs' errors (q::qs) qs1' qs2;
        _ :
          { errors, qs = reverse qs }

        esac
      esac;
    qs' [] [] qs (drop 1 qs),

  /// Corrects "qs" and returns a list with corrected quotes.
  ///
  /// Arguments:
  ///   mqs - Historic quotes of company model
  ///   qs - Historic quotes of company.
  ///
  /// Notes:
  ///   Return is:
  ///   : {
  ///   :   errors : Errors by extra o missing quotes. If there was no errors,
  ///   :            it is an empty list.
  ///   :   qs : Quotes corrected if neccessary.
  ///   : }
  correctDates mqs qs
  is list<t> -> list<t> -> { errors is list<string>, qs is list<t> } =
    fn = do errors rqs mqs qs:
      case mqs of
      mq::mqs' :
        case qs of
        q::qs' :
          if mq.date > q.date then
            fn ("\(mq.date): Missing quote"::errors)
               (mk mq.date (-1) (-1) (-1) (-1) (-1) true::rqs)
               mqs' qs
          elif mq.date < q.date then
            fn ("\(q.date): Extra quote"::errors) rqs mqs qs';
          else
            fn errors (q::rqs) mqs' qs';
          fi;
        _ :
          fn ("\(mq.date): Missing quote"::errors)
             (mk mq.date (-1) (-1) (-1) (-1) (-1) true::rqs)
             mqs' qs
        esac;
      _ :
        case qs of
        q::qs' : fn ("\(q.date): Extra quote"::errors) rqs mqs qs';
        _ : { errors = errors |> sort |> reverse, qs = reverse rqs };
        esac
     esac
     done;

    fn [] [] mqs qs,

  /// Unifies serveral list of quotes in one.
  ///
  /// Arguments:
  ///   aQs - Arrays to unify. Every quote has a .err value equals to false.
  ///   ix - The list of "aQs" selected for tiebreaks.
  unify aQs ix
  is array<list<t>> -> number -> list<t> =
    size = length aQs;
    even? = size % 2 == 0;
    mid = if even? then size / 2 else (size + 1) / 2 fi;

    hasNext aqs = any do qs: not empty? qs done aqs;

    best qs bestQ
    is list<t> -> option<t> -> t =
      case bestQ of
      Some bQ :
        { date = (head qs).date,
          open = mostDupWith (map do q: q.open done qs) bQ.open,
          close = mostDupWith (map do q: q.close done qs) bQ.close,
          max = mostDupWith (map do q: q.max done qs) bQ.max,
          min = mostDupWith (map do q: q.min done qs) bQ.min,
          vol = mostDupWith (map do q: q.vol done qs) bQ.vol,
          err = false
        };
      None () :
        { date = (head qs).date,
          open = mostDup (map do q: q.open done qs),
          close = mostDup (map do q: q.close done qs),
          max = mostDup (map do q: q.max done qs),
          min = mostDup (map do q: q.min done qs),
          vol = mostDup (map do q: q.vol done qs),
          err = false
        };
      esac;

    fn = do r aqs:
      if hasNext aqs then
        live = filter do qs: not empty? qs done aqs;
        liveLasts = map (head) live;
        maxDate = map (.date) liveLasts |> seqMost (>);
        n = seqCount do q: q.date == maxDate done liveLasts;
        r' =
          if n > mid or
            (n == mid and not even?) or
            (n == mid and not empty? aqs[ix] and (head aqs[ix]).date == maxDate)
          then
            sels = filter do q: q.date == maxDate done liveLasts;
            bestQ = if not empty? aqs[ix] and (head aqs[ix]).date == maxDate
                    then Some(head aqs[ix])
                    else None ()
                    fi;
            (best sels bestQ)::r
          else
            r
          fi;
        fn r' (map do qs:
          if not empty? qs and (head qs).date == maxDate then tail qs
          else qs
          fi
          done aqs |> array)
      else
        reverse r
      fi
      done;

    fn [] aQs,

    /// Merges new quotes with others already existent.
    ///
    /// Description:
    ///   It returns:
    ///   : errors - Errors returned by 'correct' and 'correctDates' with format
    ///   :          "date: error". If there is no error, the array is empty.
    ///   : qs - Array made with the following process:
    ///   :      1. Every quote on top with 'open = -1' is removed from "oldQs"
    ///   :         in the dates range of "newQs"
    ///   :      2. If there are new and old quotes for the same date, that of
    ///   :         'old' is selected.
    ///   :      3. The return array is corrected in the range of 'new' dates
    ///   :         and added or removed quotes maching model quotes.
    ///
    /// Arguments:
    ///   model - Model quotes. When quotes are of company model, it is an
    ///           empty array.
    ///   newQs - Last quotes read from the Internet. It can not be empty.
    ///   oldQs - Existent quotes in file system. It can not be empty.
    merge model newQs oldQs
    is list<t> -> list<t> -> list<t> ->
       { errors is list<string>, qs is list<t> } =
      mg r nqs oqs =
        case nqs of
        nq::nqs' :
          case oqs of
          oq::oqs' :
            if nq.date > oq.date then mg (nq::r) nqs' oqs
            elif nq.date < oq.date then mg (oq::r) nqs oqs'
            else mg (oq::r) nqs' oqs'
            fi;
          _ :
            mg (nq::r) nqs' oqs
          esac;
        _ :
          case oqs of
          q::qs : mg (q::r) nqs qs;
          _ : reverse r
          esac
        esac;

      oldQs = (splitBy do q: q.open >= 0 done oldQs).snd;
      qs = take cts.historicQuotes (mg [] newQs oldQs);

      {errors, qs} = if empty? model then { errors = [], qs }
                     else correctDates model qs fi;
      errors1 = errors;
      {errors, qs} = correct qs;
      { errors = (errors1 ++ errors) |> sort |> reverse, qs },
}