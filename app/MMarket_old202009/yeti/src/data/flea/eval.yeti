// Copyright 22-May-2020 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Evaluated flea data.
module data.flea.eval;

json = load es.dm.json;
flea = load data.flea.flea;
fmodel = load data.flea.fmodel;
qtable = load data.qtable;

typedef t =
  { flea is flea.t,
    var buys is number,
    var sells is number,
    var assets is number,
    var profitsAvg is number,
    var profitsVa is number,
    var eval is number
  };

{
  /// Cretes a new evaluated flea data.
  ///
  /// Arguments:
  ///   f - Flea
  mk f
  is flea.t -> t =
    { flea = f, var buys = 0, var sells = 0, var assets = 0,
      var profitsAvg = 0, var profitsVa = 0, var eval = (-1) },

  /// Returns an evaluated flea data JSONized.
  ///
  /// Arguments:
  ///   e - Evaluated data.
  toJs e
  is t -> json.t =
    json.wa
      [ flea.toJs e.flea,
        json.wn e.buys,
        json.wn e.sells,
        json.wn e.assets,
        json.wn e.profitsAvg,
        json.wn e.profitsVa,
        json.wn e.eval
      ],

  /// Returns a evaluated flea data from a JSON value.
  ///
  ///  Arguments:
  ///    js -  JSON value.
  fromJs js
  is json.t -> t =
    a = json.ra js |> array;
    { flea = flea.fromJs a[0],
      var buys = json.rn a[1],
      var sells = json.rn a[2],
      var assets = json.rn a[3],
      var profitsAvg = json.rn a[4],
      var profitsVa = json.rn a[5],
      var eval = json.rn a[6]
    },

  /// Reevaluates a list of evaluated fleas.
  ///
  /// Arguments:
  ///   md - Flea model.
  ///   opens - Open quotes table.
  ///   closes - Close quotes table.
  ///   es - Evaluated fleas list.
  evaluate md opens closes es
  is fmodel.t -> qtable.t -> qtable.t -> list<t> -> () =
    var minAssets = 2000000;
    var maxAssets = (-2000000);
    var minProfitsAvg = 2000;
    var maxProfitsAvg = (-2000);
    var minProfitsVa = 2000;
    var maxProfitsVa = (-2000);
    for es do e:
      rs = fmodel.assets md opens closes e.flea.params;
      e.buys := rs.buys;
      e.sells := rs.sells;
      e.assets := rs.assets;
      {avg, va} = fmodel.profitsAvgVa md opens closes e.flea.params;
      e.profitsAvg := avg;
      e.profitsVa := va;
      assets = e.assets;
      profitsAvg = e.profitsAvg;
      profitsVa = e.profitsVa;
      if assets < minAssets then minAssets := assets fi;
      if assets > maxAssets then maxAssets := assets fi;
      if profitsAvg < minProfitsAvg then minProfitsAvg := profitsAvg fi;
      if profitsAvg > maxProfitsAvg then maxProfitsAvg := profitsAvg fi;
      if profitsVa < minProfitsVa then minProfitsVa := profitsVa fi;
      if profitsVa > maxProfitsVa then maxProfitsVa := profitsVa fi;
      done;

    assetsDif = maxAssets - minAssets;
    profitsAvgDif = maxProfitsAvg - minProfitsAvg;
    profitsVaDif = maxProfitsVa - minProfitsVa;
    for es do e:
      e.eval := flea.evaluate e.flea
                              ((e.assets - minAssets) / assetsDif)
                              ((e.profitsAvg - minProfitsAvg) / profitsAvgDif)
                              ((e.profitsVa - minProfitsVa) / profitsVaDif)
      done,

  /// Sorts a evaluated flea list for better to worse.
  ///
  /// Arguments:
  ///   es - Evaluated fleas list.
  sort es
  is list<t> -> list<t> =
    sortBy do e1 e2: e1.eval > e2.eval done es,

  /// Returns true if "es" contains "e". Compare only 'e.flea'.
  ///
  /// Arguments:
  ///   e - Evaluated flea.
  ///   es - Evaluated fleas list.
  containsEval? e es
  is t -> list<t> -> boolean =
    any do e': flea.eq e'.flea e.flea done es,


  /// Remove duplicates (Compare only 'e.flea')
  ///
  /// Arguments:
  ///   es - Evaluated flea list.
  removeDuplicates es
  is list<t> -> list<t> =
    fn r es = case es of
              e::es' : if containsEval? e r then fn r es'
                       else fn (e::r) es' fi;
              _ : r
              esac;
    fn [] es,

  /// Adds elements from source to target, starting by the begining of source.
  /// The result is not ordered.
  ///
  /// Elements duplicated in "target" are no added.
  ///
  /// If target reaches the length of "n", the process is stopped.
  ///
  /// Arguments:
  ///   source - Evaluated fleas to add.
  ///   target - Evaluated fleas target.
  ///   n - Maximum length allowed of target.
  complete source target n
  is list<t> -> list<t> -> number -> list<t> =
    fn s t l =
      case s of
      e::s' :
        if l >= n then t
        elif containsEval? e t then fn s' t l
        else fn s' (e::t) (l + 1)
        fi;
      _ : t
      esac;
    fn source target (length target);

}
