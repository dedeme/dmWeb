// Copyright 11-Aug-2020 ºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Increment Maximum Minimum investor model.
module data.flea.models.incrMm;

matrix = load data.matrix;
fmodel = load data.flea.fmodel;

(
  // Value and position of a minimum (fn <) or a maximum (fn >).
  // start and end are inclusive and end - start + 1 == days.
  valIx fn closes iCo start end
  is (number -> number -> boolean) ->
    ~double[][] -> number -> number -> number ->
    {val is number, ix is number} =
  ( var val = closes[end][iCo];
    var ix = end - start;
    var c = 0;
    for [start..end - 1] do d:
      q' = closes[d][iCo];
      if q' >= 0 and fn q' val then
        val := q';
        ix := c
      fi;
      c := c + 1
      done;
    {val, ix};
  );

  fcalc closes params action
  is ~double[][] ->
    array<number> ->
    (~double[] -> ~double[] -> ()) ->
    () =
  ( nDays = length closes;
    nCos = length closes[0];
    days = int params[0];
    stripToBuy = params[1];
    stripToSell = params[2];

    refs = matrix.mk nCos; // Base references
    refs' = matrix.mk nCos; // References for sending to action
    ixs = matrix.mkInt nCos;
    toBuys = matrix.mkBoolean nCos;
    for [0..nCos - 1] do iCo:
      iDay = avoid do iDay:
                     closes[iDay][iCo] <= 0
                     done [0..nDays - 1];
      refs[iCo] := closes[iDay][iCo];
      toBuys[iCo] := false;
      ixs[iCo] := 0;
      done;

    for [0..nDays - 1] do iDay:
      for [0..nCos - 1] do iCo:
        q = closes[iDay][iCo];
        if iDay < days then
          refs'[iCo] := (-1);
          if q >= 0 and q < refs[iCo] then
            refs[iCo] := q;
            ixs[iCo] := iDay
          fi
        else
          ref = refs[iCo];
          if q >= 0 then
            if toBuys[iCo] then
              ref =
                if ixs[iCo] <= 0 then
                  {val, ix} = valIx (>) closes iCo (iDay - days + 1) iDay;
                  ixs[iCo] := ix;
                  if val < ref then val else ref fi
                else
                  ixs[iCo] := ixs[iCo] - 1;
                  ref
                fi;

              ref' = ref * (1 + stripToBuy);
              refs[iCo] := ref;
              refs'[iCo] := ref';
              if q > ref' then
                {val, ix} = valIx (<) closes iCo (iDay - days + 1) iDay;
                ixs[iCo] := ix;
                refs[iCo] := val;
                toBuys[iCo] := false;
                refs'[iCo] := val * (1 - stripToSell)
              fi
            else
              ref =
                if ixs[iCo] <= 0 then
                  {val, ix} = valIx (<) closes iCo (iDay - days + 1) iDay;
                  ixs[iCo] := ix;
                  if val > ref then val else ref fi
                else
                  ixs[iCo] := ixs[iCo] - 1;
                  ref
                fi;

              ref' = ref * (1 - stripToSell);
              refs[iCo] := ref;
              refs'[iCo] := ref';
              if q < ref' then
                {val, ix} = valIx (>) closes iCo (iDay - days + 1) iDay;
                ixs[iCo] := ix;
                refs[iCo] := val;
                toBuys[iCo] := true;
                refs'[iCo] := val * (1 + stripToBuy)
              fi
            fi
          fi
        fi
        done;
      action closes[iDay] refs';
      done;
  );
{
  /// Creates a model.
  mk ()
  is () -> fmodel.t =
    { id = "INCMM",
      name = "Increment Max-Min",
      parNames = ["Días", "Banda C", "Banda V"],
      parMins = array [20, 0.0001, 0.0001],
      parMaxs = array [120, 0.25, 0.25],
      parDecs = array [0, 6, 6],
      fcalc
    },
})