// Copyright 10-Aug-2018 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Module page.
module pages.mod;

load es.dm.std;
load es.dm.json;
load es.dm.buf;
{mkBuf, addBuf, bufToStr} = load es.dm.buf;
{onlyName, name} = load es.dm.path;
{dir, readAll} = load es.dm.file;
cgi = load es.dm.cgi;
db = load data.db;
eval= load yeti.lang.compiler.eval;
md = load data.moduleData;

typedef txT = {
    bf is buf,
    s is string,
    i is number
  };

typedef entryT = {
    tp is string,
    enums is list<string>,
    ms is list<string>,
    ps is list<string>
  };

typedef treeRsT = {
    tree is list<entryT>,
    html2 is string
  };

(
  tKey = "<em>typedef</em>";

  mKey = "<h3>Module signature</h3>";

  fKey = "class=\"field wdoc\">";

  fKey2 = "<span class=sn>";

  fKey2b = "<span class=vn>";

  lenFKey2 = strLength fKey2;

  add tx s = (addBuf tx.bf s; tx);

  sub tx i = strSlice tx.s tx.i i;

  move tx i = tx with {i};

  addMove tx i = move (add tx (sub tx i)) i;

  indexOf tx s = sindex' s tx.i tx.s;

  format s = (
    tx = {bf = mkBuf(), s, i = 0};
    tx = move tx (optGet (indexOf tx "<body>") + 6);

    ix = optGet (indexOf tx "</h2>") + 5;
    html1 = sub tx (ix);
    tx = move tx ix;

    tx =
      case indexOf tx "<div class=contents>" of
      None (): tx;
      Some i:
        tx = add tx (sub tx i);
        tx = move tx i;
        move tx (optGet (indexOf tx "</div>") + 6);
      esac;
    html2 = (bufToStr tx.bf) ^ (strRight tx.s tx.i);
    {html1, html2});

  mkEntry entry tx id
  is entryT -> txT -> string -> entryT = (
    ch = strChar tx.s tx.i;
    if ch >= "A" and ch <= "Z"
    then entry with {enums = id::entry.enums}
    else (
      chunk = case indexOf tx "</div>" of
              None (): "&rarr;";
              Some i: sub tx i
              esac;
      case sindex "&rarr;" chunk of
      None (): entry with {ps = id::entry.ps};
      Some _: entry with {ms = id::entry.ms}
      esac)
    fi);

  mkTypeId tx =
    case indexOf tx "=" of
    None (): None ();
    Some i:
      chunk = sub tx i;
      i0 = strLastIndexOf' chunk ">";
      if i0 < 0
      then None ()
      else Some (strRight chunk (i0 + 1) |> strTrim |>
                 strReplace "&lt;" "<" |>
                 strReplace "&gt;" ">")
      fi
    esac;

  mkTree html allPath
  is string -> string -> treeRsT = (
    mk0 entry ls tx
    is entryT -> list<entryT> -> txT -> treeRsT = (
      mk1 ix ls tx = (
        addEntry () = (
          addEntry1 tx = (
            case indexOf tx "<" of
            None (): mk0 entry ls (addMove tx ix);
            Some i:
              id = sub tx i;
              tx = move tx i;
              if strStarts? id "`" or strStarts? id "."
              then mk0 entry ls tx
              else (
                entry = mkEntry entry tx id;
                tp = entry.tp;
                tx = add tx ("<span id=\"\(tp).\(id)\"></span>" ^
                             "<a href = \"?" ^
                             "\(allPath)&hp::\(tp).\(id)\">\(id)</a>");
                mk0 entry ls tx)
              fi
            esac);

          oi =
            case indexOf tx fKey2 of
            None (): indexOf tx fKey2b;
            Some i:
              case indexOf tx fKey2b of
              None (): Some(i);
              Some i2: Some(if i < i2 then i else i2 fi)
              esac
            esac;
          case oi of
          None (): mk0 entry ls (addMove tx ix);
          Some i:
            tx = add tx ((sub tx i) ^ "<span class='link'>");
            tx = move tx (i + lenFKey2);
            addEntry1 tx
          esac);

        {op, i} =
          case indexOf tx tKey of
          None ():
            case indexOf tx mKey of
            None (): {op = 0, i = ix};
            Some i:
              if (i > ix) then {op = 0, i = ix} else {op = 2, i = i} fi
            esac;
          Some i:
            case indexOf tx mKey of
            None (): if (i > ix) then {op = 0, i = ix} else {op = 1, i = i} fi;
            Some i2:
              if (ix < i) and (ix < i2) then {op = 0, i = ix}
              elif (ix > i) and (ix > i2) then {op = 2, i = i2}
              else {op = 1, i = i}
              fi
            esac
          esac;

        if op == 0 then
          if entry.tp == "" then mk0 (entry with {tp = "~"}) ls
                                     (addMove tx ix)
          else addEntry ()
          fi
        elif op == 1 then (
          tx = addMove tx i;
          id = case mkTypeId tx of None (): "?"; Some idf: idf esac;
          ls = if entry.tp == "" then ls else entry::ls fi;
          entry = {tp = id, enums = [], ms = [], ps = []};
          mk0 entry ls (addMove tx (tx.i + 1)))
        else (
          ls = if entry.tp == "" then ls else entry::ls fi;
          entry = {tp = '~', enums = [], ms = [], ps = []};
          mk0 entry ls (addMove tx (i + 1)))
        fi);

      case indexOf tx fKey of
      None (): {tree = if entry.tp == "" then ls else entry::ls fi,
                html2 = (bufToStr tx.bf) ^ (strRight tx.s tx.i)};
      Some i: mk1 i ls tx
      esac);

    mk0 {tp = "", enums = [], ms = [], ps = []} []
        {bf = mkBuf(), s = html, i = 0});

{
  process rq =
    mpath = rstring rq["mpath"];
    fpath = rstring rq["fpath"];
    allPath = mpath ^ "@" ^ fpath;

    rp =
      case db.getPaths () |> find (_ p = p.id == mpath) of
      p::_:
        fname = fpath ^ ".yeti";
        p = p.path ^/ fname;
        tmp = db.tmpDir ();
        modules = array [];
        eval.compileYetiFiles [] [Type (push modules)] [p];
        eval.generateYetiDoc {directory = tmp, modules, error = failWith};
        case filter (_ d = (onlyName d.name) != "index") (dir tmp) of
        d::_: (
          {html1, html2} = format (readAll (tmp ^/ d.name));
          link = {name = fname, link = "?" ^ allPath ^ "&hp::"};
          {tree, html2} = mkTree html2 allPath;
          Some {title = name fpath, html1, html2, link, tree});
        _: None ();
        esac;
      _: None()
      esac;
    cgi.ok ["data": wopt md.toJson rp]
})
