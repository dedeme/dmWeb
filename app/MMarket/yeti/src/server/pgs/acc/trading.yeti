// Copyright 11-Jun-2020 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Accounting-trading page.
module server.pgs.acc.trading;

load es.dm.std;
cgi = load es.dm.cgi;
json = load es.dm.json;
load es.dm.jsonM;
sync = load es.dm.sync;
acc = load data.acc;
cts = load data.cts;
qtable = load data.qtable;
fmodel = load data.flea.fmodel;
manager = load data.manager;
conf = load db.conf;
diariesDb = load db.acc.diariesDb;
nicksTb = load db.nicksTb;
dailyTb = load db.dailyTb;
quotesDb = load db.quotesDb;
managersTb = load db.managersTb;
load std;

typedef tradingOpT =
  { toBuy is boolean,
    toSell is number,
    investors is list<number>,
    nick is string
  };

(
  mkOp toBuy toSell investors nick
  is boolean -> number -> list<number> -> string -> tradingOpT =
    { toBuy, toSell, investors, nick};

  toJs op
  is tradingOpT -> json.t =
    json.wa
      [ json.wb op.toBuy,
        json.wn op.toSell,
        jswList json.wn op.investors,
        json.ws op.nick
      ];

  addBuy ops investor nick
  is list<tradingOpT> -> number -> string -> list<tradingOpT> =
    ( fn r os =
        case os of
        o::os' :
          if o.nick == nick and o.toBuy then
            mkOp true 0 (o.investors ++ [investor]) nick::r ++ os'
          else
            fn (o::r) os'
          fi;
        _ : mkOp true 0 [investor] nick::r
        esac;
      fn [] ops
    );

  addSell ops stocks investor nick
  is list<tradingOpT> -> number -> number -> string -> list<tradingOpT> =
    ( fn r os =
        case os of
        o::os' :
          if o.nick == nick and o.toSell > 0 then
            mkOp false (o.toSell + stocks) (investor::o.investors) nick
              ::r ++ os'
          else
            fn (o::r) os'
          fi;
        _ : mkOp false stocks [investor] nick::r
        esac;
      fn [] ops
    );

{
  /// Request process.
  ///
  /// Arguments:
  ///   ck - Comunication key.
  ///   rq - Request.
  process ck rq
  is string -> hash<string, json.t> -> string =
    case cgi.rqString rq "rq" of
    "idata" :
      var rp = [:];
      sync.run do lk:
        {activity} = conf.activity ();
        closes = quotesDb.closes lk;
        nicksA = array closes.nicks;
        values = closes.values;
        lastV = length values - 1;
        lastV1 = lastV - 1;
        nkQ = [:];
        nkQ1 = [:];
        for [0..length nicksA - 1] do i:
          nkQ[nicksA[i]] := values[lastV][i];
          nkQ1[nicksA[i]] := values[lastV1][i];
          done;
        mans = managersTb.read lk;
        qs = dailyTb.read lk;
        mqs = [:];
        for qs do q:
          case nicksTb.getNick lk q.nick of
          Some nk : mqs[nk.name] := q.value;
          None () : ()
          esac
          done;
        var operations = [];
        for [0..cts.managers - 1] do i:
          anns = diariesDb.readAnnotations lk i;
          {portfolio} = acc.settlement anns;
          for nicksA do nick:
            var ref = -1;
            var ref1 = -1;
            if activity == cts.actSleeping1 or
               activity == cts.actHistoric
            then
              nkQ1[nick] := nkQ[nick];
              if nick in mqs then
                q = mqs[nick];
                nkQ[nick] := q;
                {model, params} = manager.getModel mans[i] nick;
                case qtable.nickValuesAdd closes nick q of
                Some cs :
                  refs = fmodel.refs model cs params |> reverse;
                  ref := head refs;
                  ref1 := head (tail refs);
                None () :
                  ()
                esac
              fi
            else
              {model, params} = manager.getModel mans[i] nick;
              case qtable.nickValues closes nick of
              Some cs :
                refs = fmodel.refs model cs params |> reverse;
                ref := head refs;
                ref1 := head (tail refs);
              None () :
                ()
              esac
            fi;
            if ref1 >= 0 and ref >= 0 and
               (nick in nkQ) and (nick in nkQ1)
            then
              q1 = nkQ1[nick];
              q = nkQ[nick];
              if q1 >= 0 and q >= 0 then
                if ref1 > q1 and ref < q then // buy
                  operations := addBuy operations i nick
                elif ref1 < q1 and ref > q then // sell -----------------
                  case find do e: e.nick == nick done portfolio of
                  e::_: operations := addSell operations e.stocks i nick;
                  _: ()
                  esac
                fi
              fi
            fi
            done
          done;
          rp["bet"] := json.wn cts.bet;
          rp["operations"] := jswList toJs operations;
        done;
      cgi.rp ck rp;
    k:
      failedKey k
    esac,
})
