// Copyright 15-May-2020 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Accounting data.
module data.acc;

json = load es.dm.json;
dec = load es.dm.dec;
broker = load data.broker;

typedef operationT = AnnSe { n is string, s is number, p is number }
                            // Sell nick stocks price.
                   | AnnBu { n is string, s is number, p is number }
                            // Buy nick stocks price.
                   | AnnSt { n is string, s is number, p is number }
                            // Buy nick stocks price.
                   | AnnIn number  // Income ammount.
                   | AnnWi number // Withdraw ammount.
                   | AnnPr { a is number, c is string }
                            // Profits ammount cause.
                   | AnnFe { a is number, c is string }
                            // Fees ammount cause.
                   | AnnPd { a is number, c is string }
                            // Positive differences ammount cause.
                   | AnnNd { a is number, c is string }
                            // Negative differences ammount cause.
                   ;
typedef annotationT =
  { id is number,
    date is string,
    operation is operationT
  };

typedef pfEntryT =
  { nick is string,
    stocks is number,
    price is number, // 4 decimals
    quote is number, // 4 decimals
    ref is number // 4 decimals
  };

typedef ledgerT =
  { stocks is number, // + (activo)
    cash is number, // + (activo)
    capital is number, // - (pasivo)
    sells is number, // - (pasivo) sells profits
    fees is number, // - (pasivo)
    profits is number, // - (pasivo)
    differences is number // - (pasivo)
  };

  pfAdd pf nick stocks price
  is list<pfEntryT> -> string -> number -> number -> list<pfEntryT> =
    ( var isNew? = true;
      var r = [];
      for pf do e:
        if e.nick == nick then
          r := e with { stocks = e.stocks + stocks,
                        price =
                          ((e.stocks * e.price + stocks * price) /
                          (e.stocks + stocks))
                       } :: r;
          isNew? := false
        else
          r := e :: r
        fi
        done;
      if isNew? then
        r := { nick, stocks, price, quote = -1, ref = -1 } :: r;
      fi;
      r
    );

  // stocks must be less or equals to pf.stocks.
  pfRemove pf nick stocks
  is list<pfEntryT> -> string -> number -> list<pfEntryT> =
    ( var r = [];
      for pf do e:
        if e.nick == nick then
          if e.stocks > stocks then
            r := (e with { stocks = e.stocks - stocks }) :: r
          fi
        else
          r := e :: r
        fi
        done;
      r
    );

  ledgerSell l stocks buyPrice sellPrice
  is ledgerT -> number -> number -> number -> ledgerT =
    ( cost = dec.fix'' (stocks * buyPrice);
      incom = dec.fix'' (stocks * sellPrice);
      fees = dec.fix'' (broker.fees incom);
      l with {
        stocks = l.stocks - cost,
        sells = l.sells + cost - incom,
        fees = l.fees + fees,
        cash = l.cash + incom - fees
      }
    );

  ledgerBuy l stocks price
  is ledgerT -> number -> number -> ledgerT =
    if price == 0 then
      l
    else
      cost = dec.fix'' (stocks * price);
      fees = dec.fix'' (broker.fees cost);
      l with {
        stocks = l.stocks + cost,
        fees = l.fees + fees,
        cash = l.cash - cost - fees
      }
    fi;

{
  /// Returns "ann" JSONized.
  ///
  /// Arguments:
  ///   ann - Annotation.
  annotationToJs ann
  is annotationT -> json.t =
    op = case ann.operation of
         AnnSe {n, s, p} : [json.ws "se", json.ws n, json.wn s, json.wn p];
         AnnBu {n, s, p} : [json.ws "bu", json.ws n, json.wn s, json.wn p];
         AnnSt {n, s, p} : [json.ws "st", json.ws n, json.wn s, json.wn p];
         AnnIn a : [json.ws "in", json.wn a];
         AnnWi a : [json.ws "wi", json.wn a];
         AnnPr {a, c} : [json.ws "pr", json.wn a, json.ws c];
         AnnFe {a, c} : [json.ws "fe", json.wn a, json.ws c];
         AnnPd {a, c} : [json.ws "pd", json.wn a, json.ws c];
         AnnNd {a, c} : [json.ws "nd", json.wn a, json.ws c];
         esac;
    json.wa (json.wn ann.id :: json.ws ann.date :: op),

  /// Restore an annotation JSONized.
  ///
  /// Arguments:
  ///   js - JSON value.
  annotationFromJs js
  is json.t -> annotationT =
    a = json.ra js |> array;
    { id = json.rn a[0],
      date = json.rs a[1],
      operation =
        case json.rs a[2] of
        "se" : AnnSe { n = json.rs a[3], s = json.rn a[4], p = json.rn a[5] };
        "bu" : AnnBu { n = json.rs a[3], s = json.rn a[4], p = json.rn a[5] };
        "st" : AnnSt { n = json.rs a[3], s = json.rn a[4], p = json.rn a[5] };
        "in" : AnnIn (json.rn a[3]);
        "wi" : AnnWi (json.rn a[3]);
        "pr" : AnnPr { a = json.rn a[3], c = json.rs a[4] };
        "fe" : AnnFe { a = json.rn a[3], c = json.rs a[4] };
        "pd" : AnnPd { a = json.rn a[3], c = json.rs a[4] };
        "nd" : AnnNd { a = json.rn a[3], c = json.rs a[4] };
        s : throw new Exception("Unknown operation \(s)")
        esac
    },

  /// Returns "e" JSONized.
  ///
  /// Arguments:
  ///   e - Portfolio entry.
  pfEntryToJs e
  is pfEntryT -> json.t =
    json.wa
      [ json.ws e.nick,
        json.wn e.stocks,
        json.wn e.price,
        json.wn e.quote,
        json.wn e.ref
      ],

  /// Restore a portfolio entry JSONized.
  ///
  /// Arguments:
  ///   js - JSON value.
  ledgerToJs l
  is ledgerT -> json.t =
    json.wa
      [ json.wn l.stocks,
        json.wn l.cash,
        json.wn l.capital,
        json.wn l.sells,
        json.wn l.fees,
        json.wn l.profits,
        json.wn l.differences
      ],

  /// Returns the ledger and portfolio after settle "annotations"
  ///
  /// Arguments:
  ///   annotations - Unsorted annotations.
  ///
  /// Notes:
  /// Returns:
  ///   : errors: Errors in annotations.
  ///   : ledger: Ledget
  ///   : portfolio: List of portfolio entries.
  settlement annotations
  is list<annotationT> -> { errors is list<string>, ledger is ledgerT,
                            portfolio is list<pfEntryT> } =
    fn e l pf anns =
      case anns of
      a::anns' :
        case a.operation of
        AnnSe {n, s, p} :
          if s < 0 then
            fn ("\(n): Selling \(s) (< 0) stocks"::e) l pf anns'
          elif p < 0 then
            fn ("\(n): Selling price \(p) (< 0)"::e) l pf anns'
          else
            case find do e: e.nick == n done pf of
            el::_ :
              if el.stocks < s then
                fn (("\(n): Selling \(s) stocks when in cartera there are " ^
                     "only \(el.stocks)")::e) l pf anns'
              else
                fn e (ledgerSell l s el.price p) (pfRemove pf n s) anns'
              fi;
            _ :
              fn ("\(n): Nick is missing in portfolio"::e) l pf anns'
            esac
          fi;
        AnnBu {n, s, p} :
          if s <= 0 then
            fn ("\(n): Buing \(s) (<= 0) stocks"::e) l pf anns'
          elif p < 0 then
            fn ("\(n): Buing price \(p) (<= 0)"::e) l pf anns'
          else
            fn e (ledgerBuy l s p) (pfAdd pf n s p) anns'
          fi;
        AnnSt {n, s, p} :
          amount = dec.fix'' (s * p);
          fn e (l with { capital = l.capital - amount,
                         stocks = l.stocks + amount
                       })
             (pfAdd pf n s p) anns';
        AnnIn a :
          fn e (l with { capital = l.capital - a, cash = l.cash + a }) pf anns';
        AnnWi a :
          fn e (l with { capital = l.capital + a, cash = l.cash - a }) pf anns';
        AnnPr {a, c} :
          fn e (l with { profits = l.profits - a, cash = l.cash + a }) pf anns';
        AnnFe {a, c} :
          fn e (l with { fees = l.fees + a, cash = l.cash - a }) pf anns';
        AnnPd {a, c} :
          fn e (l with { differences = l.differences - a, cash = l.cash + a })
             pf anns';
        AnnNd {a, c} :
          fn e (l with { differences = l.differences + a, cash = l.cash - a })
             pf anns';
        _ :
          fn ("Unknown annotation '\(a)'"::e) l pf anns'
        esac;
      _ :
        { errors = e, ledger = l, portfolio = pf }
      esac;
    fn []
       { stocks = 0, cash = 0, capital = 0, sells = 0, fees = 0,
         profits = 0, differences = 0
       }
       []
       (sortBy do a1 a2:
          if a1.date == a2.date then
            case a1.operation of
            AnnBu {n, s, p} : true;
            _ : case a2.operation of
                AnnBu {n , s, p} : false;
                _ : a1.id < a2.id
                esac
            esac
          else
            a1.date < a2.date
          fi
          done annotations),

  /// Returns the operations to open a new year.
  ///
  /// Arguments:
  ///   annotations - Unsorted annotations.
  ///
  /// Notes:
  /// Returns:
  ///   : errors: Errors in annotations.
  ///   : operations: List of operations.
  regularize annotations
  is list<annotationT> -> { errors is list<string>,
                            operations is list<operationT> } =
    { errors, ledger, portfolio } = settlement annotations;
    anns = map do e:
      AnnSt { n = e.nick, s = e.stocks, p = e.price }
      done portfolio;
    { errors, operations = AnnIn ledger.cash :: anns },

}
