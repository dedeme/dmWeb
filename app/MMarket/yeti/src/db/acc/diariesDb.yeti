// Copyright 15-May-2020 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Accounting diaries data base.
module db.acc.diariesDb;

load es.dm.std;
file = load es.dm.file;
json = load es.dm.json;
date = load es.dm.date;
sync = load es.dm.sync;
load es.dm.jsonM;
cts = load data.cts;
acc = load data.acc;
log = load db.log;

typedef t =
  { nextId is number,
    data is list<acc.annotationT>
  };

(
  var basePath = "";

  rpath investor = basePath ^/ "Investor-\(investor)";
  path investor =  rpath investor ^/ "diaries" ;
  ypath investor year = path investor ^/ (year ^ ".tb");

  newYearInit investor year
  is number -> string -> () =
    ( currentTb = year ^ ".tb";
      invDir = path investor;
      tbs = sortBy (>) (filter do n: strEnds? n ".tb" done (file.dir invDir));
      lastTb = head tbs;
      data = file.readAll (invDir ^/ lastTb) |> json.fromStr |> json.ra
                                             |> array;
      anns = jsrList acc.annotationFromJs data[1];
      {errors, operations} = acc.regularize anns;
      var id = 0;
      var annjs = [];
      date = year ^ "0101";
      for operations do operation:
        annjs := ({ id, date, operation } |> acc.annotationToJs) :: annjs;
        id := id + 1
        done;
      file.writeAll (invDir ^/ currentTb)
              ([json.wn id, json.wa annjs] |> json.wa |> json.toStr)
    );

{
  /// Initializes configuration table.
  ///
  /// Arguments:
  ///   parent - Parent directory (data/acc).
  init parent
  is string -> () =
    basePath := parent;
    mans = cts.managers;
    year = date.format "%Y" (date.now ());
    for [0..mans - 1] do i:
      if not file.exists? (path i) then
        file.mkdir (rpath i);
        file.mkdir (path i);
        js = json.wa [json.wn 0, json.wa []];
        file.writeAll (ypath i year) (json.toStr js)
      fi;
      if not file.exists? (ypath i year) then
        newYearInit i year
      fi
      done,

  /// Returns unsorted annotations of "year" and "investor".
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   investor - Inversor number.
  ///   year - Year to search.
  readJs lk investor year
  is sync.t -> number -> string -> option<json.t> =
    p = ypath investor year;
    if not file.exists? p then
      None ()
    else
      a = file.readAll p |> json.fromStr |> json.ra |> array;
      Some a[1]
    fi,

  /// Returns unsorted annotations of "year" of every investor.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   year - Year to search.
  readAllJs lk year
  is sync.t -> string -> json.t =
    [0..cts.managers - 1] |>
      concatMap do i:
        case readJs lk i year of
        Some anns : json.ra anns;
        None (): []
        esac
        done |> json.wa,

  /// Returns unsorted annotations data of "year" and "investor".
  ///
  /// Note:
  ///   Returns a option of:
  ///   : nextId is number - Next identifier.
  ///   : data is list<annotation.t> - Annotations
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   investor - Inversor number.
  ///   year - Year to search.
  read lk investor year
  is sync.t -> number -> string -> option<t> =
    p = ypath investor year;
    if not file.exists? p then
      None ()
    else
      a = file.readAll p |> json.fromStr |> json.ra |> array;
      Some { nextId = json.rn a[0],
             data = jsrList acc.annotationFromJs a[1]
           }
    fi,

  /// Returns unsorted annotations data of last year of an "investor".
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   investor - Inversor number.
  readAnnotations lk investor
  is sync.t -> number -> list<acc.annotationT> =
    dir = path investor;
    if file.exists? dir then
      case fold do r y: if y > r then y else r fi done "" (file.dir dir) of
      "" :
        [];
      year :
        p = path investor ^/ year;
        a = file.readAll p |> json.fromStr |> json.ra |> array;
        jsrList acc.annotationFromJs a[1]
      esac
    else
      []
    fi,

  /// Writes annotations data of "year" and "investor"
  ///
  /// Note:
  ///   "ann" is:
  ///   : nextId is number - Next identifier.
  ///   : data is list<annotation.t> - Annotations
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   investor - Inversor number.
  ///   year - Year to update.
  ///   ann - file data.
  write lk investor year ann
  is sync.t -> number -> string -> t -> () =
    js = json.wa [json.wn ann.nextId, jswList acc.annotationToJs ann.data];
    file.writeAll (ypath investor year) (json.toStr js),

  /// Returns al years with annotations of every investor, sorted from
  /// after to before.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  years lk
  is sync.t -> list<string> =
    map path [0..cts.managers - 1] |> concatMap file.dir |>
      filter do f: strEnds? f ".tb" done |> map (strLeftOf ".tb") |>
      nub |> sortBy (>),

  /// Returns the sum of cash of all the investors for a "year".
  cashAll lk year
  is sync.t -> string -> number =
    [0..cts.managers - 1] |>
      map do i:
        case read lk i year of
        Some tb : (acc.settlement tb.data).ledger.cash;
        None () : 0
        esac
        done
      |> sum,

  /// Deletes one annotation.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   investor - Investor number.
  ///   year - Year to update.
  ///   annId - Annotation identifier.
  del lk investor year annId
  is sync.t -> number -> string -> number -> () =
    case read lk investor year of
    Some tb :
      data = filter do a: a.id != annId done tb.data;
      write lk investor year { nextId = tb.nextId, data };
    None () :
      ()
    esac,

  /// Adds one annotation.
  ///
  /// Arguments:
  ///   lk - Synchronization lock.
  ///   investor - Investor number.
  ///   year - Year to update.
  ///   ann - Annotation to add.
  add lk investor year ann
  is sync.t -> number -> string -> acc.annotationT -> () =
    case read lk investor year of
    Some tb :
      ann = { id = tb.nextId, date = ann.date, operation = ann.operation };
      write lk investor year { nextId = tb.nextId + 1, data = ann::tb.data };
    None () :
      log.error lk "Table \(ypath investor year) not found.";
    esac,

})
